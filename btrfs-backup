#!/bin/ksh
#
# Bryan Burke
# bburke@baburke.net
#
# Tool to manage initialize and transfer btrfs backups
#

set -e

_config=~+/config
_dbusvar="DBUS_SESSION_BUS_ADDRESS"
_sshvar="SSH_AUTH_SOCK"
_remote_proto="sshfs"
_remote_user="$(id -u)"
_remote_host=""
_remote_path=""
_remote_image=""
_luksuuid=""
_loop=""

qflag="false"

function _msg
{
    $qflag || echo "$@"
}

function _err
{
    echo "$@" 1>&2
}

function do_backup
{
    set -x
    cd /run/btrfs-backup

    typeset _tmp="$(mktemp /tmp/btrfs-backup.XXXXXXXXXX)"
    typeset _prev="$(ls -1d ~(E)backups/home-[0-9]{4}-[0-9]{2}-[0-9]{2}-[0-9]{2} | tail -n 1)"
    _prev="$(basename ${_prev} | sed -e 's/^home-//')"

    for d in ~(E)self/home-[0-9]{4}-[0-9]{2}-[0-9]{2}-[0-9]{2}; do
        _f="$(basename $d)"
        echo "${_f##home-}"
    done > "$_tmp"

    typeset _count=0
    for d in $(<$_tmp); do
        if [[ $d > $_prev && $_count -lt 2 ]]; then
            btrfs send -p self/home-$_prev self/home-$d | btrfs receive backups
            btrfs send -p self/root-$_prev self/root-$d | btrfs receive backups
            sync
            _prev=$d
            _count=$(($_count + 1))
        fi
    done

    # Check to see if we're up-to-date and local backups can be deleted
    if [[ "$_prev" == "$(tail -n 1 $_tmp)" ]]; then
        _local="$(wc -l $_tmp | cut -d ' ' -f 1)"
        _todel=$(($_local - 24))

        for d in $(head -n $_todel $_tmp); do
            btrfs subvolume delete -C self/home-$d self/root-$d
        done
    fi

    rm -f "$_tmp"
    set +x
}

function mount_remote
{
    typeset -n _conf="$1"
    typeset _uuid="$2"
    typeset _tmpdir
    typeset _dev

    _loop=$(losetup -f)

    case "$_remote_proto" in
        "sshfs")
            export "$_sshvar"="${_conf[env][$_sshvar]}"

            _msg + Mounting \
                    ${_remote_user}@${_remote_host}:${_remote_path} \
                    on ${_conf[dirs][remote]}

            sshfs "${_remote_user}@${_remote_host}:${_remote_path}" \
                    "${_conf[dirs][remote]}"

        ;;
        *)
            _err "ERROR: Unknown protocol $_remote_proto"
            return 1
        ;;
    esac

    _msg "+ Mapping $_remote_image to $_loop"
    losetup "$_loop" "${CONF[dirs][remote]}/$_remote_image"
    _dev="$_loop"

    if "${_conf[backups][$_uuid][encrypted]}"; then
        _tmpdir="$(mktemp -d /dev/shm/btrfs-backups.XXXXXXXXXX)"
        _luksuuid="$(cryptsetup luksUUID $_loop)"

        _msg "+ Reading encryption passphrase from gnome-keyring"
        sudo "$_dbusvar"="${_conf[env][$_dbusvar]}" -u "${_conf[adminuser]}" secret-tool lookup tool btrfs-backups > "$_tmpdir/.f"

        _msg "+ Opening $_loop as luks-$_luksuuid"
        cryptsetup -q open "$_loop" "luks-$_luksuuid" --key-file "$_tmpdir/.f"
        rm -rf "$_tmpdir"
        _dev="/dev/mapper/luks-$_luksuuid"

    fi

    _msg "+ Mounting $_dev on ${_conf[dirs][backups]}"
    mount -o compress,subvolid=0 "$_dev" "${_conf[dirs][backups]}"
}

function unmount_remote
{
    typeset -n _conf="$1"
    typeset _uuid="$2"

    _msg "+ Unmounting ${_conf[dirs][backups]}"
    umount "${_conf[dirs][backups]}"

    if "${_conf[backups][$_uuid][encrypted]}"; then
        _msg "+ Closing luks-$_luksuuid"
        cryptsetup -q close "luks-$_luksuuid"
    fi

    _msg "+ Detaching $_loop"
    losetup -d "$_loop"

    case "$_remote_proto" in
        sshfs)
            _msg "+ Removing sshfs share on ${_conf[dirs][remote]}"
            fusermount -u "${_conf[dirs][remote]}"
        ;;
        *)
            _err "ERROR: Unknown protocol? \(=$_remote_proto\)"
            return 1
        ;;
    esac
}

function extract_remote
{
    typeset -n _conf="$1"
    typeset _uuid="$2"
    typeset _uri="${_conf[backups][$_uuid][uri]}"

    if [[ "$_uri" =~ ^([a-z]+)://(.*)$ ]]; then
        _remote_proto="${.sh.match[1]}"
        _uri="${.sh.match[2]}"
    fi

    _msg "+ Setting _remote_proto to $_remote_proto"

    if [[ "$_uri" =~ ^(([a-z][a-z0-9]*)?@)?(.*)$ ]]; then
        _remote_user="${.sh.match[2]}"
        _uri="${.sh.match[3]}"
    fi

    _msg "+ Setting _remote_user to $_remote_user"

    if [[ "$_uri" =~ ^([a-zA-Z.0-9_-]+)(/.*)?/([^/]+.img)$ ]]; then
        _remote_host="${.sh.match[1]}"
        _remote_path="${.sh.match[2]}"
        _remote_image="${.sh.match[3]}"
    fi

    _msg "+ Setting _remote_host to $_remote_host"
    _msg "+ Setting _remote_path to $_remote_path"
    _msg "+ Setting _remote_image to $_remote_image"

    if [[ -z "$_remote_host" || -z "$_remote_path" || \
          -z "$_remote_image" ]]; then
        return 1
    fi

    ping -nqc 1 -W 5 "$_remote_host" >/dev/null || return 1

    return 0
}

function turn_root
{
    typeset -n _conf="$1"
    shift 1

    if [[ $(id -u) != 0 ]]; then
        _msg "+ Changing UID: $(id -u) => 0"
        sudo "${_dbusvar}"="${_conf[env][$_dbusvar]}" "$@"
        _msg "+ Exiting unprivileged shell"
        exit $?
    fi

    return 0
}

function mount_local
{
    typeset -n _conf="$1"
    typeset _uuid="$2"

    _msg + "Mounting ${_conf[backups][$_uuid][localuuid]}" \
            "on ${_conf[dirs][self]}"
    mount -o subvolid=0 UUID="${_conf[backups][$_uuid][localuuid]}" \
            "${_conf[dirs][self]}"

    return $?
}

function unmount_local
{
    typeset -n _conf="$1"

    _msg "+ Unmounting ${_conf[dirs][self]}"
    umount "${_conf[dirs][self]}"

    return $?
}

. "$_config"
turn_root "CONF" "$0" "$@"

for _uuid in "${!CONF[backups][@]}"; do
    mount_local "CONF" "$_uuid"

    if ! extract_remote "CONF" "$_uuid"; then
        _err "Failed to parse URI = ${CONF[backups][$_uuid][uri]}"
        _err "Trying next backup"
        unmount_local "CONF"
        continue
    fi

    mount_remote "CONF" "$_uuid"
    do_backup
    unmount_remote "CONF" "$_uuid"
    unmount_local "CONF"
done
